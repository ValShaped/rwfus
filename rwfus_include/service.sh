
source rwfus_include/testlog.sh

function check_casefold {
    sudo dumpe2fs `findmnt -oSOURCE -DvenufT $1` 2>&1 | head -n 10 | grep -q casefold
}

function generate_service_script {
    # Add config-parsing to the bootstrapper script
    cat <<EOF
#!/bin/bash
# This file is automatically generated as part of the installation process.
# Changes made to this file will not persist when updating $Name.
echo "$Name v$Version ${TESTMODE+[Test Mode active]}"
echo "$Description"

EOF
    cat rwfus_include/info.sh         # Copy the project's info to the script
    printf "\n# config: Load only\n"
    echo "Config_File=\"$Config_File\""   # Copy the Config  path to the script, so it knows where to load from
    declare -f load_config            # Copy the load_config function to the script
    printf "\n# mount: and unmount\n"
    cat rwfus_include/mount.sh        # Copy the mount and unmount functions to the script
    printf "\n# service-main: argument parsing and function running\n"
    cat rwfus_include/service-main.sh # Parse args and run the correct function
}

function generate_service_unit {
    local script_path=$1
    local after=${2:-"basic.target"}           # Start the unit after system (filesystem, swap, etc.) is up
    local wanted_by=${3:-"multi-user.target"}  # Start the unit before multi-user.target

cat <<-EOF
# Generated by $Name v$Version
[Unit]
Description=$Description
Requires=$wanted_by
After=$after

[Service]
Type=oneshot
RemainAfterExit=yes
TimeoutSec=3
ExecStart=$script_path --enable
ExecStop=$script_path --disable

[Install]
WantedBy=$wanted_by
EOF
}

function generate_service {
    local service_name="${Name@L}d"
    local script_path="$Service_Directory/$service_name.sh"
    local unit_path="$Service_Directory/$service_name.service"
    printf "Generating service $service_name\n  script $script_path\n  unit   $unit_path\n"
    generate_service_script > $script_path && \
        chmod +x $script_path
    generate_service_unit $script_path > $unit_path
}

function enable_service {
    # Mask pacman-cleanup.service, which automatically deletes pacman keyring on reboot
    Log Test systemctl mask -- "pacman-cleanup.service"
    # Print command instead of enabling service, in test mode
    Log Test systemctl enable --now -- `list_service`
    if [[ $? != 0 ]]; then Log -p echo "Error when enabling service. See "$logfile" for information."; return -1; fi
}

function disable_service {
    # Print command instead of enabling service, in test mode
    Log Test systemctl disable --now -- `list_service`
    if [[ $? != 0 ]]; then Log -p echo "Error when disabling service. See "$logfile" for information."; return 1; fi
    # Unmask pacman-cleanup.service, which automatically deletes pacman keyring on reboot
    Log Test systemctl unmask -- "pacman-cleanup.service"
}

function delete_service {
    local out=0
    for unit in `list_service`; do
        Log rm -v -- "$Systemd_Directory/$unit";
        if [[ $? != 0 ]]; then Log -p echo "Error when deleting service. See "$logfile" for information."; return -1; fi
        out=$(( $out+$? ))
    done
}

function stat_service {
    if [[ -d $Service_Directory ]]; then
        SYSTEMD_COLORS=1 Test systemctl status --lines 0 --no-pager -- `list_service`
    fi
}

function list_service {
    find $Service_Directory -name "*.service" -printf "%f"
}
